-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParAMPL where
import AbsAMPL
import LexAMPL
import ErrM

}

%name pAMPLCODE AMPLCODE
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%cohandles' { PT _ (TS _ 2) }
  '%constructors' { PT _ (TS _ 3) }
  '%destructors' { PT _ (TS _ 4) }
  '%functions' { PT _ (TS _ 5) }
  '%handles' { PT _ (TS _ 6) }
  '%include' { PT _ (TS _ 7) }
  '%processes' { PT _ (TS _ 8) }
  '(' { PT _ (TS _ 9) }
  ')' { PT _ (TS _ 10) }
  ',' { PT _ (TS _ 11) }
  '-' { PT _ (TS _ 12) }
  '.' { PT _ (TS _ 13) }
  '.ampl' { PT _ (TS _ 14) }
  '/' { PT _ (TS _ 15) }
  ':' { PT _ (TS _ 16) }
  ':=' { PT _ (TS _ 17) }
  ';' { PT _ (TS _ 18) }
  '=' { PT _ (TS _ 19) }
  '=>' { PT _ (TS _ 20) }
  '[' { PT _ (TS _ 21) }
  ']' { PT _ (TS _ 22) }
  'as' { PT _ (TS _ 23) }
  'into' { PT _ (TS _ 24) }
  'of' { PT _ (TS _ 25) }
  'on' { PT _ (TS _ 26) }
  'with' { PT _ (TS _ 27) }
  '{' { PT _ (TS _ 28) }
  '|' { PT _ (TS _ 29) }
  '}' { PT _ (TS _ 30) }

L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }
L_Store { PT _ (T_Store _) }
L_Load { PT _ (T_Load _) }
L_Ret { PT _ (T_Ret _) }
L_Call { PT _ (T_Call _) }
L_ConstInt { PT _ (T_ConstInt _) }
L_ConstChar { PT _ (T_ConstChar _) }
L_ConstString { PT _ (T_ConstString _) }
L_ToStr { PT _ (T_ToStr _) }
L_ToInt { PT _ (T_ToInt _) }
L_And { PT _ (T_And _) }
L_Or { PT _ (T_Or _) }
L_Append { PT _ (T_Append _) }
L_Unstring { PT _ (T_Unstring _) }
L_LeqI { PT _ (T_LeqI _) }
L_EqI { PT _ (T_EqI _) }
L_Leqc { PT _ (T_Leqc _) }
L_Eqc { PT _ (T_Eqc _) }
L_Leqs { PT _ (T_Leqs _) }
L_Eqs { PT _ (T_Eqs _) }
L_ConcatS { PT _ (T_ConcatS _) }
L_Add { PT _ (T_Add _) }
L_Subtract { PT _ (T_Subtract _) }
L_Mul { PT _ (T_Mul _) }
L_Quot { PT _ (T_Quot _) }
L_Rem { PT _ (T_Rem _) }
L_Cons { PT _ (T_Cons _) }
L_Case { PT _ (T_Case _) }
L_Rec { PT _ (T_Rec _) }
L_Get { PT _ (T_Get _) }
L_Put { PT _ (T_Put _) }
L_Hput { PT _ (T_Hput _) }
L_Hcase { PT _ (T_Hcase _) }
L_Split { PT _ (T_Split _) }
L_Fork { PT _ (T_Fork _) }
L_Plug { PT _ (T_Plug _) }
L_Run { PT _ (T_Run _) }
L_Close { PT _ (T_Close _) }
L_Halt { PT _ (T_Halt _) }
L_Ch_Id { PT _ (T_Ch_Id _) }
L_Main_run { PT _ (T_Main_run _) }
L_Character { PT _ (T_Character _) }
L_UIdent { PT _ (T_UIdent _) }
L_PIdent { PT _ (T_PIdent _) }
L_PInteger { PT _ (T_PInteger _) }


%%

String  :: { String }  : L_quoted {  $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Store    :: { Store} : L_Store { Store (mkPosToken $1)}
Load    :: { Load} : L_Load { Load (mkPosToken $1)}
Ret    :: { Ret} : L_Ret { Ret (mkPosToken $1)}
Call    :: { Call} : L_Call { Call (mkPosToken $1)}
ConstInt    :: { ConstInt} : L_ConstInt { ConstInt (mkPosToken $1)}
ConstChar    :: { ConstChar} : L_ConstChar { ConstChar (mkPosToken $1)}
ConstString    :: { ConstString} : L_ConstString { ConstString (mkPosToken $1)}
ToStr    :: { ToStr} : L_ToStr { ToStr (mkPosToken $1)}
ToInt    :: { ToInt} : L_ToInt { ToInt (mkPosToken $1)}
And    :: { And} : L_And { And (mkPosToken $1)}
Or    :: { Or} : L_Or { Or (mkPosToken $1)}
Append    :: { Append} : L_Append { Append (mkPosToken $1)}
Unstring    :: { Unstring} : L_Unstring { Unstring (mkPosToken $1)}
LeqI    :: { LeqI} : L_LeqI { LeqI (mkPosToken $1)}
EqI    :: { EqI} : L_EqI { EqI (mkPosToken $1)}
Leqc    :: { Leqc} : L_Leqc { Leqc (mkPosToken $1)}
Eqc    :: { Eqc} : L_Eqc { Eqc (mkPosToken $1)}
Leqs    :: { Leqs} : L_Leqs { Leqs (mkPosToken $1)}
Eqs    :: { Eqs} : L_Eqs { Eqs (mkPosToken $1)}
ConcatS    :: { ConcatS} : L_ConcatS { ConcatS (mkPosToken $1)}
Add    :: { Add} : L_Add { Add (mkPosToken $1)}
Subtract    :: { Subtract} : L_Subtract { Subtract (mkPosToken $1)}
Mul    :: { Mul} : L_Mul { Mul (mkPosToken $1)}
Quot    :: { Quot} : L_Quot { Quot (mkPosToken $1)}
Rem    :: { Rem} : L_Rem { Rem (mkPosToken $1)}
Cons    :: { Cons} : L_Cons { Cons (mkPosToken $1)}
Case    :: { Case} : L_Case { Case (mkPosToken $1)}
Rec    :: { Rec} : L_Rec { Rec (mkPosToken $1)}
Get    :: { Get} : L_Get { Get (mkPosToken $1)}
Put    :: { Put} : L_Put { Put (mkPosToken $1)}
Hput    :: { Hput} : L_Hput { Hput (mkPosToken $1)}
Hcase    :: { Hcase} : L_Hcase { Hcase (mkPosToken $1)}
Split    :: { Split} : L_Split { Split (mkPosToken $1)}
Fork    :: { Fork} : L_Fork { Fork (mkPosToken $1)}
Plug    :: { Plug} : L_Plug { Plug (mkPosToken $1)}
Run    :: { Run} : L_Run { Run (mkPosToken $1)}
Close    :: { Close} : L_Close { Close (mkPosToken $1)}
Halt    :: { Halt} : L_Halt { Halt (mkPosToken $1)}
Ch_Id    :: { Ch_Id} : L_Ch_Id { Ch_Id (mkPosToken $1)}
Main_run    :: { Main_run} : L_Main_run { Main_run (mkPosToken $1)}
Character    :: { Character} : L_Character { Character (mkPosToken $1)}
UIdent    :: { UIdent} : L_UIdent { UIdent (mkPosToken $1)}
PIdent    :: { PIdent} : L_PIdent { PIdent (mkPosToken $1)}
PInteger    :: { PInteger} : L_PInteger { PInteger (mkPosToken $1)}

AMPLCODE :: { AMPLCODE }
AMPLCODE : ListAMPL_CONSTRUCTS START { AbsAMPL.Main (reverse $1) $2 }
AMPL_CONSTRUCTS :: { AMPL_CONSTRUCTS }
AMPL_CONSTRUCTS : IMPORT { AbsAMPL.IMPORT_CONSTRUCT $1 }
                | HANDLES { AbsAMPL.HANDLE_CONSTRUCT $1 }
                | COHANDLES { AbsAMPL.COHANDLE_CONSTRUCT $1 }
                | CONSTRUCTORS { AbsAMPL.CONSTRUCTOR_CONSTRUCT $1 }
                | DESTRUCTORS { AbsAMPL.DESTRUCTOR_CONSTRUCT $1 }
                | PROCESSES { AbsAMPL.PROCESSES_CONSTRUCT $1 }
                | FUNCTIONS { AbsAMPL.FUNCTIONS_CONSTRUCT $1 }
ListAMPL_CONSTRUCTS :: { [AMPL_CONSTRUCTS] }
ListAMPL_CONSTRUCTS : {- empty -} { [] }
                    | ListAMPL_CONSTRUCTS AMPL_CONSTRUCTS { flip (:) $1 $2 }
HANDLE_SPEC :: { HANDLE_SPEC }
HANDLE_SPEC : UIdent '=' '{' ListHandle '}' { AbsAMPL.Hand_spec $1 $4 }
Handle :: { Handle }
Handle : UIdent { AbsAMPL.HandName $1 }
ListHANDLE_SPEC :: { [HANDLE_SPEC] }
ListHANDLE_SPEC : {- empty -} { [] }
                | HANDLE_SPEC { (:[]) $1 }
                | HANDLE_SPEC ';' ListHANDLE_SPEC { (:) $1 $3 }
ListHandle :: { [Handle] }
ListHandle : Handle { (:[]) $1 }
           | Handle ';' ListHandle { (:) $1 $3 }
IMPORTS :: { IMPORTS }
IMPORTS : ListIMPORT { AbsAMPL.Imports (reverse $1) }
LUIDENT :: { LUIDENT }
LUIDENT : PIdent { AbsAMPL.LIDENT $1 }
        | UIdent { AbsAMPL.UIDENT $1 }
DirPath :: { DirPath }
DirPath : ListLUIDENT { AbsAMPL.DIRPATH $1 }
ListLUIDENT :: { [LUIDENT] }
ListLUIDENT : LUIDENT { (:[]) $1 }
            | LUIDENT '/' ListLUIDENT { (:) $1 $3 }
Slash :: { Slash }
Slash : '/' { AbsAMPL.SLASH } | {- empty -} { AbsAMPL.SLASH_NONE }
ListIMPORT :: { [IMPORT] }
ListIMPORT : {- empty -} { [] }
           | ListIMPORT IMPORT { flip (:) $1 $2 }
IMPORT :: { IMPORT }
IMPORT : '%include' Slash DirPath '.ampl' { AbsAMPL.Import $2 $3 }
CONSTRUCTORS :: { CONSTRUCTORS }
CONSTRUCTORS : '%constructors' ':' '{' ListSTRUCTOR_SPEC '}' { AbsAMPL.Constructors $4 }
DESTRUCTORS :: { DESTRUCTORS }
DESTRUCTORS : '%destructors' ':' '{' ListSTRUCTOR_SPEC '}' { AbsAMPL.Destructors $4 }
STRUCTOR_SPEC :: { STRUCTOR_SPEC }
STRUCTOR_SPEC : UIdent '=' '{' ListSTRUCT '}' { AbsAMPL.Struct_spec $1 $4 }
STRUCT :: { STRUCT }
STRUCT : UIdent PInteger { AbsAMPL.Struct $1 $2 }
ListSTRUCTOR_SPEC :: { [STRUCTOR_SPEC] }
ListSTRUCTOR_SPEC : {- empty -} { [] }
                  | STRUCTOR_SPEC { (:[]) $1 }
                  | STRUCTOR_SPEC ';' ListSTRUCTOR_SPEC { (:) $1 $3 }
ListSTRUCT :: { [STRUCT] }
ListSTRUCT : STRUCT { (:[]) $1 }
           | STRUCT ';' ListSTRUCT { (:) $1 $3 }
HANDLES :: { HANDLES }
HANDLES : '%handles' ':' '{' ListHANDLE_SPEC '}' { AbsAMPL.Handles $4 }
COHANDLES :: { COHANDLES }
COHANDLES : '%cohandles' ':' '{' ListHANDLE_SPEC '}' { AbsAMPL.Cohandles $4 }
PROCESSES :: { PROCESSES }
PROCESSES : '%processes' ':' '{' ListPROCESS_SPEC '}' { AbsAMPL.Processes $4 }
ListPROCESS_SPEC :: { [PROCESS_SPEC] }
ListPROCESS_SPEC : {- empty -} { [] }
                 | PROCESS_SPEC { (:[]) $1 }
                 | PROCESS_SPEC ';' ListPROCESS_SPEC { (:) $1 $3 }
PROCESS_SPEC :: { PROCESS_SPEC }
PROCESS_SPEC : PIdent '(' ListVars '|' ListPIdent '=>' ListPIdent ')' '=' COMS { AbsAMPL.Process_spec $1 $3 $5 $7 $10 }
Vars :: { Vars }
Vars : PIdent { AbsAMPL.VName $1 }
ListVars :: { [Vars] }
ListVars : {- empty -} { [] }
         | Vars { (:[]) $1 }
         | Vars ',' ListVars { (:) $1 $3 }
FUNCTIONS :: { FUNCTIONS }
FUNCTIONS : '%functions' ':' '{' ListFUNCTION_SPEC '}' { AbsAMPL.Functions $4 }
ListFUNCTION_SPEC :: { [FUNCTION_SPEC] }
ListFUNCTION_SPEC : {- empty -} { [] }
                  | FUNCTION_SPEC { (:[]) $1 }
                  | FUNCTION_SPEC ';' ListFUNCTION_SPEC { (:) $1 $3 }
FUNCTION_SPEC :: { FUNCTION_SPEC }
FUNCTION_SPEC : PIdent '(' ListVars ')' '=' COMS { AbsAMPL.Function_spec $1 $3 $6 }
START :: { START }
START : Main_run CHANNEL_SPEC ':' COMS { AbsAMPL.Start $1 $2 $4 }
      | {- empty -} { AbsAMPL.Start_none }
CHANNEL_SPEC :: { CHANNEL_SPEC }
CHANNEL_SPEC : '(' '|' ListPIdent '=>' ListPIdent ')' { AbsAMPL.Channel_specf $3 $5 }
             | '(' ListCInteger '=>' ListCInteger ')' { AbsAMPL.Channel_spec $2 $4 }
COMS :: { COMS }
COMS : '{' ListCOM '}' { AbsAMPL.Prog $2 }
ListCOM :: { [COM] }
ListCOM : {- empty -} { [] }
        | COM { (:[]) $1 }
        | COM ';' ListCOM { (:) $1 $3 }
COM :: { COM }
COM : PIdent ':=' COM { AbsAMPL.AC_ASSIGN $1 $3 }
    | Store PIdent { AbsAMPL.AC_STOREf $1 $2 }
    | Load PIdent { AbsAMPL.AC_LOADf $1 $2 }
    | Ret { AbsAMPL.AC_RET $1 }
    | Call PIdent '(' ListPIdent ')' { AbsAMPL.AC_CALLf $1 $2 $4 }
    | ConstInt CInteger { AbsAMPL.AC_INT $1 $2 }
    | ConstChar Character { AbsAMPL.AC_CHAR $1 $2 }
    | ConstString String { AbsAMPL.AC_STRING $1 $2 }
    | ToStr { AbsAMPL.AC_TOSTR $1 }
    | ToInt { AbsAMPL.AC_TOINT $1 }
    | And { AbsAMPL.AC_AND $1 }
    | Or { AbsAMPL.AC_OR $1 }
    | Append { AbsAMPL.AC_APPEND $1 }
    | Unstring { AbsAMPL.AC_UNSTRING $1 }
    | LeqI { AbsAMPL.AC_LEQ $1 }
    | EqI { AbsAMPL.AC_EQ $1 }
    | Leqc { AbsAMPL.AC_LEQC $1 }
    | Eqc { AbsAMPL.AC_EQC $1 }
    | Leqs { AbsAMPL.AC_LEQS $1 }
    | Eqs { AbsAMPL.AC_EQS $1 }
    | ConcatS Integer { AbsAMPL.AC_CONCAT $1 $2 }
    | Add { AbsAMPL.AC_ADD $1 }
    | Subtract { AbsAMPL.AC_SUB $1 }
    | Mul { AbsAMPL.AC_MUL $1 }
    | Quot { AbsAMPL.AC_DIVQ $1 }
    | Rem { AbsAMPL.AC_DIVR $1 }
    | Cons '(' PInteger ',' PInteger ')' { AbsAMPL.AC_CONS $1 $3 $5 }
    | UIdent '.' UIdent { AbsAMPL.AC_STRUCT $1 $3 }
    | UIdent '.' UIdent '(' ListPIdent ')' { AbsAMPL.AC_STRUCTas $1 $3 $5 }
    | Case 'of' '{' ListLABELCOMS '}' { AbsAMPL.AC_CASEf $1 $4 }
    | Rec 'of' '{' ListLABELCOMS '}' { AbsAMPL.AC_RECORDf $1 $4 }
    | UIdent '.' UIdent PIdent { AbsAMPL.AC_DESTl $1 $3 $4 }
    | UIdent '.' UIdent '(' ListPIdent ')' PIdent { AbsAMPL.AC_DESTlas $1 $3 $5 $7 }
    | Get PIdent 'on' PIdent { AbsAMPL.AC_GETf $1 $2 $4 }
    | Hput PIdent UIdent '.' UIdent { AbsAMPL.AC_HPUTf $1 $2 $3 $5 }
    | Hcase PIdent 'of' '{' ListLABELCOMS '}' { AbsAMPL.AC_HCASEf $1 $2 $5 }
    | Put PIdent { AbsAMPL.AC_PUTf $1 $2 }
    | Split PIdent 'into' PIdent PIdent { AbsAMPL.AC_SPLITf $1 $2 $4 $5 }
    | Fork PIdent 'as' '{' PIdent 'with' ListPIdent ':' COMS ';' PIdent 'with' ListPIdent ':' COMS '}' { AbsAMPL.AC_FORKf $1 $2 $5 $7 $9 $11 $13 $15 }
    | Plug ListPIdent 'as' '{' 'with' '[' ListPIdent ']' ':' COMS ';' 'with' '[' ListPIdent ']' ':' COMS '}' { AbsAMPL.AC_PLUGf $1 $2 $7 $10 $14 $17 }
    | Run PIdent '(' ListPIdent '|' ListPIdent '=>' ListPIdent ')' { AbsAMPL.AC_RUNf $1 $2 $4 $6 $8 }
    | PIdent Ch_Id PIdent { AbsAMPL.AC_IDF $1 $2 $3 }
    | '(' ListPIdent ')' { AbsAMPL.AC_PROD $2 }
    | '#' CInteger '(' PIdent ')' { AbsAMPL.AC_PRODELEM $2 $4 }
    | String { AbsAMPL.AC_EMSG $1 }
    | Close PIdent { AbsAMPL.AC_CLOSEf $1 $2 }
    | Halt ListPIdent { AbsAMPL.AC_HALTf $1 $2 }
LABELCOMS :: { LABELCOMS }
LABELCOMS : UIdent '.' UIdent ':' COMS { AbsAMPL.Labelcoms1 $1 $3 $5 }
          | UIdent '.' UIdent '(' ListPIdent ')' ':' COMS { AbsAMPL.Labelcoms2 $1 $3 $5 $8 }
ListCOMS :: { [COMS] }
ListCOMS : {- empty -} { [] }
         | COMS { (:[]) $1 }
         | COMS ',' ListCOMS { (:) $1 $3 }
ListLABELCOMS :: { [LABELCOMS] }
ListLABELCOMS : {- empty -} { [] }
              | LABELCOMS { (:[]) $1 }
              | LABELCOMS ';' ListLABELCOMS { (:) $1 $3 }
ListPIdent :: { [PIdent] }
ListPIdent : {- empty -} { [] }
           | PIdent { (:[]) $1 }
           | PIdent ',' ListPIdent { (:) $1 $3 }
CInteger :: { CInteger }
CInteger : PInteger { AbsAMPL.Positive $1 }
         | '-' PInteger { AbsAMPL.Negative $2 }
ListCInteger :: { [CInteger] }
ListCInteger : {- empty -} { [] }
             | CInteger { (:[]) $1 }
             | CInteger ',' ListCInteger { (:) $1 $3 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

